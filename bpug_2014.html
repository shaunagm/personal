<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Welcome to WelcomeBot - Boston Python User Group Preesentation Night, December 2014</title>

		<meta name="description" content="A talk about harmful conversational behaviors and how to address them">
		<meta name="author" content="Shauna Gordon-McKeon">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/bpug_2014.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		
	</head>
	
	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides" style="width:1350px; height:700px;">
			
			    	<section class="title-page meta" data-background="#036564">
			    	    <h1>Building a WelcomeBot</h1>	
			    	    <p class="filler"></p>
			    	    <h4>Boston Python User Group, December 2014</h4>
			    	    <p class="filler"></p>
			    	    <h5>Shauna Gordon-McKeon (@shauna_gm, shauna@openhatch.org, shauna on Freenode)</h5>
				    </section>
				    
				    <section class="info" data-background="#033649">
				        <h3>The background</h3>
				        <img style="width: 800px;" src="images/ghc2014/shauna_teaching.jpg">
				    </section>
				    
				    <section class="info" data-background="#033649">
				    <h3>The problem</h3>
				    <img style="width: 900px;" src="images/bpug2014/nobot.png">
				    </section>
				    
				  	<section class="info" data-background="#033649">
				    <h3>The solution</h3>
				   <img src="images/bpug2014/sweetbot.png">
				    </section> 
				   
				    <section class="question" data-background="#E8DDCB"> <!-- SANITY CHECK THIS -->
				    <h4>So what is WelcomeBot?</h4>
				    <h4 class="fragment">So what is IRC?</h4>
                    <h4 class="fragment">So what is an application layer protocol?</h4>
                    <aside class="notes">
-- What is WelcomeBot?  A program written in Python which uses the socket library to connect to IRC servers, join IRC channels, and message IRC users.
-- What is IRC?  There's actually a few ways to answer that.  One way is to think of IRC as a tool, or platform.  In that way, you can think of IRC as something like AOL Instant Messenger, or AIM.  I like comparing it to AIM because AIM was the first chat client that I ever used.  It's a tool that allows you to talk to people, either in group chats, called channels, or in private messages.  Another way to think of IRC is as a protocol.  In fact, it's what's known as an application layer protocol.
-- What's an application layer protocol?  So in order to communicate with each other, nodes on a network need to agree on a basic syntax, an abstract structure, so that can establish when they're being talked to, who is talking to them, and neat things like that.  There's different layers of abstraction.  So for instance, there's IP, which is a very low level protocol.  TCP, which is the transport layer protocol - you hear these things being referred to together as TCP/IP.  And then, there's application level.  Another application level protocol is HTTP, which our web browsers use, and SSH, which allows you to create secure encrypted connections.  IRC is at that level of protocol.
                    </aside>
				    </section>
				    
				    <section class="question" data-background="#E8DDCB">
				        <h4>Try it!  @ <a href="http://bit.ly/ircbot-python">bit.ly/ircbot-python</a></h4>
				        <p class="filler"></p>
    				    <iframe src="http://wiki.shellium.org/w/Writing_an_IRC_bot_in_Python"></iframe>
				    </section>
				    
				    <section class="question" data-background="#E8DDCB">
    				    <h4>Socket Library</h4>
    				    <p class="filler"></p>
    				    <p>We start by creating a socket object, with some details about the connection we want to make.</p>
    				    <pre>ircsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</pre>
    				    <p class="filler"></p>
    				    <p>We then use this object to connect to the server on port 6667.</p>
    				    <pre>server = "irc.freenode.net" 
ircsock.connect((server, 6667))</pre>
                        <aside class="notes">
                            Note: AF_INET = address family, INET: IPv4, so the server variable, irc.freenode.net, is mapped to ipv4.  Sock_stream is another connection variable which I looked up but didn't really understand.
                        </aside>
    				   
				    </section>
				    
				    <section class="question" data-background="#E8DDCB">
    				    <h4>Socket Library (cont)</h4>
    				    <p class="filler"></p>
    				    <p>We can now communicate using <tt>send</tt> and <tt>recv</tt>:</p>
    				    <pre>
ircsock.send("PRIVMSG "+ channel +" :Hello!\n")
ircsock.recv(2048)</pre>
    				    <p class="filler"></p>
    				    <p>These sent messages can include a variety of IRC syntax:</p>
    				    <pre>ircsock.send("PONG :pingis\n")  
ircsock.send("JOIN "+ chan +"\n")
ircsock.send("NICK "+ botnick +"\n") </pre>
				    </section>
				    
                    <section class="meta" data-background="#036564">
    				    <h3>Basic Structure of WelcomeBot</h3>
    				    <p>(as seen at <a href="https://github.com/shaunagm/WelcomeBot/">https://github.com/shaunagm/WelcomeBot/</a>)</p>
    				    <ul>
    				    <li>If newcomer joins, create a newcomer object with a datetime field.</li>
    				    <li>If a non-newcomer speaks into the channel, silently record nickname and delete newcomer object.</li>
    				    <li>Regularly check how long the newcomer has been around.</li>
    				    <li>Once the newcomer has been around for longer than a set time (default is 60 seconds) greet them.</li>
    				    </ul>
				    </section>
				    
				    <section class="meta ps" data-background="#036564">
				        <h3>A mistake!</h3>
				        <h3>aka a learning experience</h3>
				        <p class="filler"></p>
				        <p>How do you listen and respond at the same time?</p>
				        <p class="filler"></p>
				        <pre class="fragment">import queue, threading
def getIRC():
    q = Queue.LifoQueue()
    while True:
        ircmsg = ircsock.recv(2048) # receive data from the server
        ircmsg = ircmsg.strip('\n\r') # removing any unnecessary linebreaks.
        q.put(ircmsg)
t = Thread(target=getIRC)
t.daemon = True
t.start()
                    </pre>
                    <aside class="notes">
                    So, one of the first worries I had when trying to adapt this basic script to fit my needs was that the bot needs to be able to do a few things at once.  It wants to receive IRC messages, but it also wants to be checking how long newcomers have been in the channel and welcoming them and processing them as needed.  My first solution to this used the thread and queue libraries.  

I'm not going to go into a lot of detail here, but just briefly, you can see - this code creates a Last In, First Out queue, so processing things in the order its received.  It's then wrapped in a thread, which means it can sort of hum along on repeat in the background while the bot does other stuff.  So, from my perspective, this was great - the bot could take care of business while not missing a message.

                    </aside>
                    </section>
                    
                    <section class="meta ps" data-background="#036564">
				        <h3>Totally unnecessary</h3>
				        <p class="filler"></p>
				        <pre class="fragment">import select
ready_to_read, b, c = select.select([ircsock],[],[], 1)</pre>
                    <aside class="notes">
                    Turns out that's all totally unnecessary.  Operating systems, having been designed by reasonable people, recognize that you might want to do other things instead of waiting constantly by the phone for a call, and so they save a backlog of connections.  Great!  So I got rid of threading and queuing.  Instead, I just needed to know when to access that backlog, that is - when a message had been received.  Unix systems have a tool called select() which the python select library uses, which keeps track of when objects - sockets, but also files -  have been changed.  The select.select() function takes three parameters, which are lists of objects you want to check.  The first is for things you want to read, the second is for things you want to write to, and the third is waiting for exceptional conditions - of course, we just want to read, so we use the first parameter. The last parameter is an optional timeout argument.  Here, we're saying check, wait one second, and move on.  

                    </aside>
  				    </section>
				    
				    <section class="meta" data-background="#036564">
				        <h3>Learning experience for everyone</h3>
				        <p>12 contributors, including 6 who are making their first open source contribution!</p>
				        <ul>
				        <li>Saves known nicknames</li>
				        <li>Recognizes patterns of nicknames, eg "shauna__" as "shauna"</li>
				        <li>Responds to greetings and requests for more info</li>
				        <li>Best of all...</li>
				        </ul>
				    </section>
				    
					<section class="meta ps" data-background="#036564">
				        <h3>Tests!</h3>
				        <pre>class TestBotClass(unittest.TestCase):

    def setUp(self):
        self.bot = botcode.Bot()
        
    def test_known_nicks_setup(self):
        bot = botcode.Bot('test_nicks.csv')
        self.assertEqual(bot.known_nicks, [['Alice'], ['Bob']])

    def test_add_nick_underscore_removal(self):
        self.bot.known_nicks = [['Fluffy'], ['Spot']]
        self.bot.add_known_nick('Roger__')
        self.assertEqual(self.bot.known_nicks,[['Fluffy'], ['Spot'], ['Roger']])

    def tearDown(self):
        with open('test_nicks.csv', 'w') as csv_file:
            csv_file.write('Alice\nBob\n')</pre>
				    </section>	    
			
		<section class="info" data-background="#033649">
			    <h3>Thanks!</h3>
			    <p class="filler"></p>
			    <h4>Guides</h4>
			    <p>Ned (seriously, watch his <a href="https://www.youtube.com/watch?v=FxSsnHeWQBY">Ned's Pycon 2014 talk on unit testing</a>), Asheesh Laroia, and the kind folks at project night.</p>
			    <p class="filler"></p>
			    <h4>Contributors</h4>
			    <p class="filler">jbertino, artLopez, aaparella, clarissavazquez, dcarrot2, ppegusii, sunu, BananaObserved, lkuper, kwurst and Aaron1011</p>
			</section>
				    
			</div>

        </div>

<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				margin: 0.05,
				width: 1200,
				height:650,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>

    </body>

</html>
